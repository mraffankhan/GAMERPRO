# System Architecture: Secure Esports Tournament Management

## 1. Architecture Overview
**Stack:** Next.js (App Router), Supabase (PostgreSQL, Auth, RLS).

The system prioritizes **integrity** and **security**. All sensitive logic (grouping, qualification) is admin-controlled. Validation occurs server-side via RLS policies and discrete API actions.

---

## 2. Database Schema

### Core Tables
Existing: `profiles` (users), `teams`, `tournaments`.
**New Required Tables:**

```sql
-- Track tournament stages/rounds (e.g., Qualifiers, Quarter-Finals)
-- (Optional: simplifies logic if stages have specific configs)
-- For this design, we can manage stages as a string field in 'groups' if simple, 
-- but a dedicated logic suggests explicit Stage management.

-- GROUPS: The container for teams in a specific stage
CREATE TABLE groups (
  id bigint generated by default as identity primary key,
  tournament_id bigint references tournaments(id) not null,
  stage_name text not null, -- e.g., "Round 1", "Quarter-Finals"
  name text not null, -- e.g., "Group A"
  created_at timestamp with time zone default now()
);

-- GROUP_TEAMS: Mapping teams to groups
CREATE TABLE group_teams (
  id bigint generated by default as identity primary key,
  group_id bigint references groups(id) not null,
  team_id bigint references teams(id) not null,
  assigned_at timestamp with time zone default now(),
  UNIQUE(group_id, team_id)
);

-- MATCHES: Scheduled games for a group
CREATE TABLE matches (
  id bigint generated by default as identity primary key,
  group_id bigint references groups(id) not null,
  start_time timestamp with time zone not null,
  room_id text, -- Encrypted or protected via RLS
  room_password text, -- Encrypted or protected via RLS
  created_at timestamp with time zone default now()
);

-- QUALIFICATIONS: Tracking who moves forward
CREATE TABLE qualifications (
  id bigint generated by default as identity primary key,
  tournament_id bigint references tournaments(id) not null,
  team_id bigint references teams(id) not null,
  from_stage text not null,
  to_stage text not null,
  qualified_at timestamp with time zone default now(),
  UNIQUE(tournament_id, team_id, from_stage)
);
```

---

## 3. Automatic Grouping Logic

**Goal:** Randomly divide qualified teams into groups of 12.

### Algorithm (Pseudo-Code)

```javascript
function generateGroups(tournamentId, stageName, teamIds) {
  // 1. Shuffle teams using Fisher-Yates algorithm for fairness
  const shuffledTeams = shuffle(teamIds);
  
  // 2. Calculate chunks
  const GROUP_SIZE = 12;
  const groups = [];
  
  // 3. Create Chunks
  while (shuffledTeams.length > 0) {
    groups.push(shuffledTeams.splice(0, GROUP_SIZE));
  }
  
  // 4. Handle Remainder (Wildcard Logic)
  // If the last group has fewer than 12 teams, they are the "Wildcard/Waiting" group.
  // Admin requires explicit logic: strict 12 or allow smaller?
  // Requirement says: "remaining teams are placed in a waiting/wildcard group"
  
  // 5. Database Transaction
  // - Create Group records (Group A, Group B...)
  // - Insert into group_teams
}
```

---

## 4. Security & Access Control (RLS)

### Match Credentials Security
**Requirement:** Visible only 15 minutes before match.

**RLS Policy for `matches` table (SELECT):**
```sql
CREATE POLICY "View Match Credentials"
ON matches
FOR SELECT
TO authenticated
USING (
  -- User must be in the team that is in the group of this match
  EXISTS (
    SELECT 1 FROM group_teams gt
    JOIN team_members tm ON gt.team_id = tm.team_id
    WHERE gt.group_id = matches.group_id
    AND tm.user_id = auth.uid()
  )
  AND
  -- Time check: Now >= Start Time - 15 minutes
  now() >= (matches.start_time - interval '15 minutes')
);
```
*Note: Admins have a separate policy to view always.*

---

## 5. Admin Workflow (Step-by-Step)

1.  **Review Registration:**
    *   Admin views list of all registered teams for Tournament X.
    *   Teams with incomplete rosters (checked by `members_count`) are flagged.

2.  **Qualification:**
    *   Admin selects valid teams -> clicks "Qualify for Round 1".
    *   System records qualification entries.

3.  **Grouping:**
    *   Admin clicks "Generate Groups".
    *   System runs randomization algorithm.
    *   Groups (A, B, C...) are created. Valid groups have 12 teams. Remainder in "Wildcard".

4.  **Scheduling:**
    *   Admin assigns `start_time` for each Group (e.g., Group A plays at 2:00 PM).
    *   Admin enters `room_id` and `room_password`.

5.  **Go Live:**
    *   Players view their "My Matches" dashboard.
    *   At T-15 minutes, the room ID/Password reveals automatically.

---

## 6. Scalability Considerations

*   **Database**: use `bigint` for IDs to support millions of records.
*   **Reads**: Heavy read load on "My Matches" page at tournament start. Indexes on `team_members(user_id)` and `group_teams(team_id)` are critical.
*   **Realtime**: Use Supabase Realtime mainly for Admin dashboard updates (e.g., new registrations). Clients should poll or use Realtime sparingly for Match ID reveal to prevent connection storms.
